#include <stdio.h>
#include <vector>

using namespace std;
/* leetcode issue 62 
 * 动态规划四部曲
 * 第一步 确定状态：
 *  1. 具体来看最后一步的情况
 *      由题意可知，到达右下角的方式只有两种，一是从右下角的上方到达，而是从右下角的左边到达
 *      那么就比较清晰了，到达右下角的方式就等于前述两种方式之和
 *  2. 子问题
 *      ok，经过上面的分析，我们只需要知道到达右下角的左边有几种方式，到达右下角的上边有几种方式即可
 *      原问题：到达右下角有几种方式
 *      子问题：到达右下角的左/上方有几种方式
 *      可以清楚的看到，问题和原来一模一样，但是我们已经把问题规模缩小了，那么这确定无疑是一个动态规划的问题
 *      那么我们就可以用一个数组dp[m][n]来记录到达dp[m][n]的方式
 * 第二步 确定转移方程：
 *  经过上面的分析其实已经比较清晰了，转移方程就等于到达上方的方式+到达左边的方式
 *  也就是dp[m][n] = dp[m-1][n] + dp[m][n-1]
 * 第三步 确定初始值和边界情况：
 *  分析题意可知，到达第一行只有一种方式，就是一直往右走，到达第一列同理
 *  也就是if(i == 0 || j == 0) dp[m][n]=1;
 * 第四步 循环方式：
 *  这里比较常规，就是从小到大循环
 */

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n,0));
        dp[0][0] = 1;
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
};
